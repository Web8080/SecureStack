import redis
import json
import hashlib
from typing import Dict, Any, Optional
from datetime import timedelta
import logging

from config import settings

logger = logging.getLogger(__name__)


class VulnerabilityCache:
    def __init__(self):
        try:
            self.redis_client = redis.from_url(settings.REDIS_URL, decode_responses=True)
            self.redis_client.ping()
        except Exception as e:
            logger.warning(f"Redis not available, using in-memory cache: {e}")
            self.redis_client = None
            self.memory_cache = {}
    
    def _get_cache_key(self, package_name: str, version: str, ecosystem: str) -> str:
        key_string = f"{ecosystem}:{package_name}:{version}"
        return f"vuln:{hashlib.md5(key_string.encode()).hexdigest()}"
    
    def get(self, package_name: str, version: str, ecosystem: str = "npm") -> Optional[Dict[str, Any]]:
        cache_key = self._get_cache_key(package_name, version, ecosystem)
        
        if self.redis_client:
            try:
                cached = self.redis_client.get(cache_key)
                if cached:
                    return json.loads(cached)
            except Exception as e:
                logger.error(f"Cache get error: {e}")
        else:
            return self.memory_cache.get(cache_key)
        
        return None
    
    def set(
        self,
        package_name: str,
        version: str,
        data: Dict[str, Any],
        ecosystem: str = "npm",
        ttl: int = 86400
    ):
        cache_key = self._get_cache_key(package_name, version, ecosystem)
        
        if self.redis_client:
            try:
                self.redis_client.setex(
                    cache_key,
                    ttl,
                    json.dumps(data)
                )
            except Exception as e:
                logger.error(f"Cache set error: {e}")
        else:
            self.memory_cache[cache_key] = data
    
    def invalidate(self, package_name: str, version: str, ecosystem: str = "npm"):
        cache_key = self._get_cache_key(package_name, version, ecosystem)
        
        if self.redis_client:
            try:
                self.redis_client.delete(cache_key)
            except Exception as e:
                logger.error(f"Cache invalidate error: {e}")
        else:
            self.memory_cache.pop(cache_key, None)

